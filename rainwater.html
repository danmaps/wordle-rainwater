<html>
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
    <script defer src="https://pyscript.net/latest/pyscript.js"></script>
</head>
<body>
    <textarea type="textarea" id="userinput" cols="20" rows="9">Your wordle score ?/6
    
â¬›â¬›â¬›â¬›â¬›
â¬›â¬›â¬›â¬›ðŸŸ©
ðŸŸ©â¬›â¬›â¬›ðŸŸ©
ðŸŸ©â¬›ðŸŸ©â¬›ðŸŸ©
ðŸŸ©â¬›ðŸŸ©â¬›ðŸŸ©</textarea><br>
    <button id="btn">make it rain</button>


    <div id="output"></div>

    <!--<img src="problem.png" alt="the problem">-->

    <py-env>
    </py-env>

    <py-script>
    from js import console, document
    from pyodide.ffi.wrappers import add_event_listener # https://jeff.glass/post/pyscript-why-create-proxy/
    
    # https://www.techiedelight.com/trapping-rain-water-within-given-set-bars/
    import sys
    
    # Function to find the amount of water that can be trapped within
    # a given set of bars in linear time and extra space
    def trap(bars):

        changes = []
    
        n = len(bars)
        if n <= 2:
            return 0
    
        water = 0
    
        # `left[i]` stores the maximum height of a bar to the left
        # of the current bar
        left = [None] * (n - 1)
        left[0] = -sys.maxsize
    
        # process bars from left to right
        for i in range(1, n - 1):
            left[i] = max(left[i - 1], bars[i - 1])
    
        # `right` stores the maximum height of a bar to the right
        # of the current bar
        right = -sys.maxsize
    
        # process bars from right to left
        for i in reversed(range(1, n - 1)):
            right = max(right, bars[i + 1])
    
            # check if it is possible to store water in the current bar
            if min(left[i], right) > bars[i]:
                water += min(left[i], right) - bars[i]
                console.log(f"add {min(left[i], right) - bars[i]} water to column {i}")
                changes.append((i,min(left[i], right) - bars[i]))
                # print(changes)
    
        return water,changes

    # test the function
    # assert trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6

    def wordle_to_matrix(input_text):
        '''takes a copied wordle score and returns a list of lists of 1s and 0s'''
        # split the input text into lines
        lines = input_text.split("\n")

        # extract the dimensions of the puzzle
        puzzle_lines = lines[2:]
        rows = len(puzzle_lines)
        cols = len(puzzle_lines[0])

        # initialize 0s matrix
        puzzle = [[0 for _ in range(cols)] for _ in range(rows)]

        # parse the puzzle from the input text
        for n, line in enumerate(puzzle_lines):
            for m, c in enumerate(line):
                if c != "â¬›":
                    # if the character is not black, set the corresponding cell to 1
                    puzzle[n][m] = 1

        # for line in puzzle:
        #     print(line)
        return puzzle

    def to_elevation_map(puzzle):
        '''takes a puzzle matrix and returns a list of heights'''
        elevation_map = []
        
        # for each column in the puzzle
        for col in range(len(puzzle[0])):
            # iterate from the top row to the bottom row
            for row in range(len(puzzle)):
                if puzzle[row][col] == 1:
                    # if the cell is not black, add the height of the cell to the elevation map
                    elevation_map.append(len(puzzle) - row)
                    break
            else:
                # if the column is entirely black, add a height of 0 to the elevation map
                elevation_map.append(0)
        
        # return the elevation map as a list of heights
        return elevation_map

    def calculate(input_text):
        return(to_elevation_map(wordle_array(input_text)))

    def list_to_icons(lst):
        # Define a dictionary to map numbers to icons
        icons = {0: "â¬›", 1: "ðŸŸ©", 2: "ðŸŸ¦"}
        # Initialize an empty string to store the output
        output = ""
        # Loop through each sublist in the list
        for sublist in lst:
            # Loop through each number in the sublist
            for num in sublist:
                # Append the corresponding icon to the output
                output += icons[num]
            # Append a newline character to the output
            output += "\n"
        # Return the output string
        return output

    def downfill(matrix):
        for row in range(len(matrix)-2,-1,-1):
            for col in range(len(matrix[0])):
                if matrix[row][col] == 0:
                    for i in range(row+1, len(matrix)):
                        if matrix[i][col] == 1:
                            matrix[row][col] = 1
                            break
        for row in matrix:
            print(row)
        return matrix



    def addwater(matrix, changes):
        ''' replace the correct chars in wordle_array(message) with "ðŸŸ¦"
        using changes like this [(3, 3), (2, 1), (1, 3)]

        [0, 0, 0, 0, 0]   
        [0, 0, 0, 0, 1]
        [1, 0, 0, 0, 1]
        [1, 0, 1, 0, 1]
        [1, 0, 1, 0, 1]

        ->

        [0, 0, 0, 0, 0]
        [0, 0, 0, 0, 1]
        [1, 2, 2, 2, 1]
        [1, 2, 1, 2, 1]
        [1, 2, 1, 2, 1]
        '''
           
        # Apply changes to the matrix
        for col, num_zeros in changes:
            for i in range(len(matrix)-1, -1, -1):
                if num_zeros == 0:
                    break
                if matrix[i][col] == 0:
                    matrix[i][col] = 2
                    num_zeros -= 1
            
        # for row in matrix:
        #     print(row)

        return list_to_icons(matrix)

    def run_it(*args):
        # Get the user input
        message = document.getElementById("userinput").value
        console.log(message)
        
        # Create the output element
        output = Element("output")
        
        # Convert the input message to a matrix of elevation values
        matrix = wordle_to_matrix(message)
        elev_map = to_elevation_map(matrix)
        
        # Compute the amount of water that can be trapped and the required changes
        water, changes = trap(elev_map)
        
        # Add water to the matrix according to the required changes
        changed_matrix = addwater(downfill(matrix), changes)
        
        # Set the output text to display the elevation map, the amount of water, and the changed matrix
        output_text = str(elev_map) + "\n" + str(water) + " water" + "\n" + str(changed_matrix)
        output.element.innerText = output_text


    add_event_listener(document.getElementById("btn"), "click", run_it)
    add_event_listener(document.getElementById("userinput"), "submit", run_it)

    </py-script>

</body>
</html>

